{"metadata":{"guid":"718202c0-b40a-48c2-b4ae-b9a980e62c23","url":"/v2/streaming_pipelines/718202c0-b40a-48c2-b4ae-b9a980e62c23","created_at":"2020-07-23T20:49:03Z","updated_at":"2020-10-15T17:55:39Z","revision":1602784539173},"entity":{"name":"sample.edge-mnist","description":"","project_guid":"355f24fb-ca55-49af-8065-ac843dd8af96","graph":{"doc_type":"pipeline","version":"1.0","json_schema":"http://www.ibm.com/ibm/wdp/flow-v1.0/pipeline-flow-v1-schema.json","id":"","app_data":{"ui_data":{"name":"sample.edge-mnist"},"parameters":[{"name":"delay","type_code":"str","value":"0"},{"name":"confidence_threshold","type_code":"str","value":"0.8"},{"name":"window_length","type_code":"str","value":"10"},{"name":"source","type_code":"str","value":"0"},{"name":"repeat","type_code":"str","value":"0"},{"name":"camera","type_code":"str","value":"camera-1"}]},"primary_pipeline":"primary-pipeline","pipelines":[{"id":"primary-pipeline","runtime":"streams","nodes":[{"id":"code_yjpvyn50nc","type":"binding","op":"ibm.streams.sources.code","outputs":[{"id":"target","schema_ref":"schema0","links":[{"node_id_ref":"wml_deployment_82ii87fadv2","port_id_ref":"source"}]}],"parameters":{"code":"import sys\nimport time\nimport logging\nfrom random import randint, uniform \nimport json\nimport datetime\nimport streamsx.ec\n\n# Import for MNIST dataset \nimport mnist\nimport socket\n\n# User logs include messages at INFO, WARN and ERROR levels\nlogger = logging.getLogger(__name__)\n\n\nclass Code(object):\n    # Called when flow is starting to run\n    def __enter__(self):\n        self.delay = int(streamsx.ec.get_submission_time_value('delay'))\n        self.camera = str(streamsx.ec.get_submission_time_value('camera'))\n        self.x_test = mnist.test_images()\n        self.y_test = mnist.test_labels()\n\n    def __call__(self):\n        images = self.x_test\n        labels = self.y_test\n        samples_count = len(images)\n        self.camera = self.camera + \"-\" + socket.gethostname()\n        while True:\n            # Send a new tuple every <delay> seconds\n            time.sleep(self.delay)\n            \n            rand_idx = randint(1, samples_count)\n            rand_img = images[rand_idx - 1 : rand_idx]\n            one_dim_pixel_arr = rand_img.reshape(-1)\n            label = labels[rand_idx - 1]\n            prep_time = uniform(0.1, 1)\n\n            # Send the tuple\n            yield {\n                \"image\": json.dumps(one_dim_pixel_arr.tolist()),\n                # \"ground_truth_label\": label, # The correct number in the image\n                \"camera\": self.camera, # String representing Camera ID\n                \"timestamp_str\": datetime.datetime.utcnow().isoformat() + \"Z\",\n                \"input_time\": time.monotonic(), # Used later to calculate image scoring time\n                \"prep_time\": prep_time\n            }\n\n    # Called to handle an exception or shutdown\n    def __exit__(self, exc_type, exc_value, traceback):\n        pass\n","code_style":"Class","schema_mapping":[{"name":"image","type":"string","length":0,"source_elem_name":"","target_elem_name":""},{"name":"camera","type":"string","length":0,"source_elem_name":"","target_elem_name":""},{"name":"timestamp_str","type":"string","length":0,"source_elem_name":"","target_elem_name":""},{"name":"input_time","type":"double","length":0,"source_elem_name":"","target_elem_name":""},{"name":"prep_time","type":"double","length":0,"source_elem_name":"","target_elem_name":""}]},"app_data":{"ui_data":{"label":"Image Generator","x_pos":-160,"y_pos":118.80000000000001}}},{"id":"wml_deployment_82ii87fadv2","type":"execution_node","op":"ibm.streams.operations.wml-deployment","outputs":[{"id":"target","schema_ref":"schema1","links":[{"node_id_ref":"code_46yol8hm5ky","port_id_ref":"source"}]}],"parameters":{"inline_scoring":true,"model_id":"96f53afb-ac4e-4939-a6c1-a6c022442b53","schema_mapping_inputsource":[{"name":"image","type":"array","path":"image"}],"input_schema":[{"name":"image","type":"array","nullable":true}],"schema_mapping":[{"name":"result_class","type":"double","path":"prediction"},{"name":"predictions","type":"string","length":0,"target_elem_name":"","path":"probability"},{"name":"camera","type":"string","path":"From input"},{"name":"timestamp_str","type":"string","path":"From input"},{"name":"input_time","type":"double","path":"From input"},{"name":"prep_time","type":"double","path":"From input"},{"name":"image","type":"string","path":"From input"}]},"app_data":{"ui_data":{"label":"WML MNIST model","x_pos":64,"y_pos":118.80000000000001}}},{"id":"code_46yol8hm5ky","type":"execution_node","op":"ibm.streams.operations.code","outputs":[{"id":"target","schema_ref":"schema2","links":[{"node_id_ref":"code_vk2o739etgb","port_id_ref":"source"},{"node_id_ref":"code_4ltip15fw96","port_id_ref":"source"}]}],"parameters":{"code":"import sys\nimport logging\nimport time\nimport ast \n\n# User logs include messages at INFO, WARN and ERROR levels\nlogger = logging.getLogger(__name__)\n\nclass Code(object):\n    # Called when flow is starting to run\n    # def __enter__(self):\n    #     pass\n\n    def __call__(self, event):        \n        # Calculate processing/prediction time of WML model\n        event['predict_time'] = time.monotonic() - event['input_time']\n        \n        # Convert quoted array into an array\n        # Ex. '[1, 2, 3, 4, 5]' -> [1, 2, 3, 4, 5]\n        prob_array = ast.literal_eval(event['predictions'])\n\n        # Convert the predicted digit from float to int\n        pred_int = int(event['result_class'])\n\n        # Get the prediction probability as a float\n        event['result_probability'] = float(prob_array[pred_int])\n        \n        # prediction_probabilities[result_class]\n        return event\n\n    # Called to handle an exception or shutdown\n    # def __exit__(self, exc_type, exc_value, traceback):\n    #     pass","schema_mapping":[{"name":"result_class","type":"double"},{"name":"result_probability","type":"double","length":0,"source_elem_name":"","target_elem_name":""},{"name":"predictions","type":"string","length":0,"target_elem_name":""},{"name":"camera","type":"string","length":0,"target_elem_name":""},{"name":"timestamp_str","type":"string","length":0,"target_elem_name":""},{"name":"predict_time","type":"double","length":0,"target_elem_name":""},{"name":"prep_time","type":"double","length":0,"target_elem_name":""},{"name":"input_time","type":"double","length":0,"target_elem_name":""},{"name":"image","type":"string"}]},"app_data":{"ui_data":{"label":"post-process","x_pos":288,"y_pos":118.80000000000001}}},{"id":"code_vk2o739etgb","type":"execution_node","op":"ibm.streams.operations.code","outputs":[{"id":"target","schema_ref":"schema3","links":[{"node_id_ref":"code_zupu8tdnw0g","port_id_ref":"source"}]}],"parameters":{"code":"import sys\nimport logging\nimport streamsx.ec\n\n\n# User logs include messages at INFO, WARN and ERROR levels\nlogger = logging.getLogger(__name__)\n\nclass Code(object):\n    # Called when flow is starting to run\n    def __enter__(self):\n        self.threshold = float(streamsx.ec.get_submission_time_value('confidence_threshold'))\n\n    def __call__(self, event):        \n        if event['result_probability'] <= self.threshold:\n            return event\n\n    # Called to handle an exception or shutdown\n    # def __exit__(self, exc_type, exc_value, traceback):\n    #     pass","schema_mapping":[{"name":"result_class","type":"double"},{"name":"result_probability","type":"double","length":0,"target_elem_name":""},{"name":"predictions","type":"string","length":0,"target_elem_name":""},{"name":"camera","type":"string","length":0,"target_elem_name":""},{"name":"timestamp_str","type":"string","length":0,"target_elem_name":""},{"name":"predict_time","type":"double","length":0,"target_elem_name":""},{"name":"prep_time","type":"double","length":0,"target_elem_name":""},{"name":"input_time","type":"double"},{"name":"image","type":"string"}]},"app_data":{"ui_data":{"label":"Confidence filter","x_pos":512,"y_pos":39.6}}},{"id":"code_zupu8tdnw0g","type":"execution_node","op":"ibm.streams.operations.code","outputs":[{"id":"target","schema_ref":"schema4","links":[{"node_id_ref":"kafka_1ho0faymkto","port_id_ref":"source"}]}],"parameters":{"code":"import sys\nimport logging\nimport json\n\n\n# User logs include messages at INFO, WARN and ERROR levels\nlogger = logging.getLogger(__name__)\n\nclass Code(object):\n    # Called when flow is starting to run\n    # def __enter__(self):\n    #     pass\n\n    def __call__(self, event):\n        return {\n            \"uncertain_metrics_json\": json.dumps(event)\n            }\n\n    # Called to handle an exception or shutdown\n    # def __exit__(self, exc_type, exc_value, traceback):\n    #     pass","schema_mapping":[{"name":"uncertain_metrics_json","type":"string","length":0,"source_elem_name":""}]},"app_data":{"ui_data":{"label":"Json Converter","x_pos":736,"y_pos":39.6}}},{"id":"kafka_1ho0faymkto","type":"binding","op":"ibm.streams.targets.kafka","parameters":{},"app_data":{"ui_data":{"label":"Low confidence metrics - Kafka","x_pos":960,"y_pos":39.6}}},{"id":"code_4ltip15fw96","type":"execution_node","op":"ibm.streams.operations.code","outputs":[{"id":"target","schema_ref":"schema5","links":[{"node_id_ref":"code_pr5dwrfo5x","port_id_ref":"source"}]}],"parameters":{"code":"import sys\nimport logging\n\n# User logs include messages at INFO, WARN and ERROR levels\nlogger = logging.getLogger(__name__)\n\nclass Code(object):\n    # This code block doesn't do anything beyond simplifying the output schema\n    # Specifically it removes the list of prediction probabilities and the image\n    # def __enter__(self):\n    #     pass\n\n    def __call__(self, event):\n        # event['word_count'] = len(event['phrase'].split())\n        return event\n\n    # Called to handle an exception or shutdown\n    # def __exit__(self, exc_type, exc_value, traceback):\n    #     pass","schema_mapping":[{"name":"result_class","type":"double"},{"name":"result_probability","type":"double","length":0,"target_elem_name":""},{"name":"camera","type":"string","length":0,"target_elem_name":""},{"name":"timestamp_str","type":"string","length":0,"target_elem_name":""},{"name":"predict_time","type":"double","length":0,"target_elem_name":""},{"name":"prep_time","type":"double","length":0,"target_elem_name":""}]},"app_data":{"ui_data":{"label":"Simplify stream","x_pos":512,"y_pos":198.00000000000003}}},{"id":"code_pr5dwrfo5x","type":"execution_node","op":"ibm.streams.operations.code","outputs":[{"id":"target","schema_ref":"schema6","links":[{"node_id_ref":"code_45or8y7oo8e","port_id_ref":"source"}]}],"parameters":{"code":"import sys\nimport logging\nfrom datetime import datetime, timedelta\nimport pickle\nimport time\nimport streamsx.ec\n\n\n\n\n# User logs include messages at INFO, WARN and ERROR levels\nlogger = logging.getLogger(__name__)\n\nclass Code(object):\n    # Called when flow is starting to run\n    def __enter__(self):\n        window_length = int(streamsx.ec.get_submission_time_value('window_length'))\n        self.window_timedelta = timedelta(seconds=window_length)\n        self.window = []\n        self.window_begin = None\n\n    def __call__(self, event):\n        now = datetime.now()\n        return_window = None\n        # Create new window\n        if self.window_begin is None:\n            self.window_begin = now\n        \n        # If difference between current time is start of window is greater than our desired window duration\n        # return this window \n        if now - self.window_begin > self.window_timedelta:\n            return_window = self.window\n            self.window = []\n            self.window_begin = now\n        \n        # add the current tuple/event to the window\n        self.window.append(event)\n        if return_window is not None:\n            return {\n                \"tuples_in_window\": pickle.dumps(return_window)\n            }\n\n    # Called to handle an exception or shutdown\n    # def __exit__(self, exc_type, exc_value, traceback):\n    #     pass","schema_mapping":[{"name":"tuples_in_window","type":"blob","length":0,"source_elem_name":""}]},"app_data":{"ui_data":{"label":"Batch","x_pos":736,"y_pos":198.00000000000003}}},{"id":"code_45or8y7oo8e","type":"execution_node","op":"ibm.streams.operations.code","outputs":[{"id":"target","schema_ref":"schema7","links":[{"node_id_ref":"kafka_q7z8v9c92yo","port_id_ref":"source"}]}],"parameters":{"code":"import sys\nimport logging\n\nimport subprocess\nimport os\nimport os.path\nimport pickle\nimport numpy as np\nimport datetime\nimport json\nimport streamsx.ec\n\n\n# User logs include messages at INFO, WARN and ERROR levels\nlogger = logging.getLogger(__name__)\n\n# Compute per-camera digit count metrics from a set of results in a window\n# We also distinguish between cases where we were fairly certain and cases where we were not.\ndef compute_metrics(tuples, threshold, duration, delay, repeat, parallelism, source):\n    if len(tuples) > 0:\n        # Group the prep times of each tuple in the window into an array\n        prep_times = np.array([x['prep_time'] for x in tuples])\n        \n        # Group prediction times of each tuple in the window into an array\n        predict_times = np.array([x[\"predict_time\"] for x in tuples])\n\n        # For each camera, calculate how many confident vs not-confident predictions for each class\n        counts = dict()\n        for t in tuples:\n            # For each camera, create an\n            if t[\"camera\"] not in counts:\n                counts[t[\"camera\"]] = {\n                    \"certain\": [0 for i in range(11)],\n                    \"uncertain\": [0 for i in range(11)],\n                }\n\n            if t[\"result_probability\"] > threshold:\n                counts[t[\"camera\"]][\"certain\"][t[\"result_class\"]] += 1\n            else:\n                counts[t[\"camera\"]][\"uncertain\"][t[\"result_class\"]] += 1\n\n        return {\n            \"camera_metrics\": counts,\n            \"timestamp\": datetime.datetime.utcnow().isoformat() + \"Z\",\n            \"config\": {\n                \"delay\": delay,\n                'repeat': repeat,\n                \"confidence\": threshold,\n                \"classify_parallel\": parallelism,\n                \"metrics_duration\": duration,\n            },\n            \"latency_metrics\": {\n                'prep': {\n                    'min': float(prep_times.min()),\n                    'max': float(prep_times.max()),\n                    'mean': float(prep_times.mean()),\n                    'std': float(prep_times.std()),\n                    'percentiles': np.percentile(\n                        prep_times, [50, 75, 90, 99]\n                    ).tolist()\n                },\n                \"predict\": {\n                    \"min\": float(predict_times.min()),\n                    \"max\": float(predict_times.max()),\n                    \"mean\": float(predict_times.mean()),\n                    \"std\": float(predict_times.std()),\n                    \"percentiles\": np.percentile(\n                        predict_times, [50, 75, 90, 99]\n                    ).tolist(),\n                },\n            },\n        }\n    else:\n        return None\n\n\n# N/A\nget_scoring_parallelism = lambda: 1\n\n\nclass Code(object):\n    # Called when flow is starting to run\n    def __enter__(self):\n        self.threshold = float(streamsx.ec.get_submission_time_value('confidence_threshold'))\n        # The length of each window in seconds\n        self.window_length = int(streamsx.ec.get_submission_time_value('window_length'))\n        # The delay between each tuple at the source\n        self.delay = int(streamsx.ec.get_submission_time_value('delay'))\n        # (dummy value) How many times to repeat the dataset.  0 indicates to repeat forever.\n        self.repeat = int(streamsx.ec.get_submission_time_value('repeat'))\n        # (dummy value) Source type.  That is, where to get images from - default = 0\n        self.source = int(streamsx.ec.get_submission_time_value('source'))\n\n    def __call__(self, event):\n        tuples_in_window = pickle.loads(event[\"tuples_in_window\"])\n        if tuples_in_window is not None:\n            # Convert the prediction from float to int\n            for t in tuples_in_window:\n                t[\"result_class\"] = int(t[\"result_class\"])\n            metrics = compute_metrics(\n                tuples_in_window,\n                self.threshold,\n                self.window_length,\n                self.delay,\n                self.repeat, \n                get_scoring_parallelism(),\n                self.source\n            )\n            return {'metrics_json': json.dumps(metrics)}\n\n    # Called to handle an exception or shutdown\n    # def __exit__(self, exc_type, exc_value, traceback):\n    #     pass\n","schema_mapping":[{"name":"metrics_json","type":"string","length":0,"source_elem_name":""}]},"app_data":{"ui_data":{"label":"Aggregate Metrics","x_pos":960,"y_pos":198.00000000000003}}},{"id":"kafka_q7z8v9c92yo","type":"binding","op":"ibm.streams.targets.kafka","parameters":{},"app_data":{"ui_data":{"label":"Aggregate metrics - Kafka","x_pos":1184,"y_pos":198.00000000000003}}}]}],"schemas":[{"id":"schema0","fields":[{"name":"image","type":"string"},{"name":"camera","type":"string"},{"name":"timestamp_str","type":"string"},{"name":"input_time","type":"double"},{"name":"prep_time","type":"double"}]},{"id":"schema1","fields":[{"name":"result_class","type":"double"},{"name":"predictions","type":"string"},{"name":"camera","type":"string"},{"name":"timestamp_str","type":"string"},{"name":"input_time","type":"double"},{"name":"prep_time","type":"double"},{"name":"image","type":"string"}]},{"id":"schema2","fields":[{"name":"result_class","type":"double"},{"name":"result_probability","type":"double"},{"name":"predictions","type":"string"},{"name":"camera","type":"string"},{"name":"timestamp_str","type":"string"},{"name":"predict_time","type":"double"},{"name":"prep_time","type":"double"},{"name":"input_time","type":"double"},{"name":"image","type":"string"}]},{"id":"schema3","fields":[{"name":"result_class","type":"double"},{"name":"result_probability","type":"double"},{"name":"predictions","type":"string"},{"name":"camera","type":"string"},{"name":"timestamp_str","type":"string"},{"name":"predict_time","type":"double"},{"name":"prep_time","type":"double"},{"name":"input_time","type":"double"},{"name":"image","type":"string"}]},{"id":"schema4","fields":[{"name":"uncertain_metrics_json","type":"string"}]},{"id":"schema5","fields":[{"name":"result_class","type":"double"},{"name":"result_probability","type":"double"},{"name":"camera","type":"string"},{"name":"timestamp_str","type":"string"},{"name":"predict_time","type":"double"},{"name":"prep_time","type":"double"}]},{"id":"schema6","fields":[{"name":"tuples_in_window","type":"blob"}]},{"id":"schema7","fields":[{"name":"metrics_json","type":"string"}]}]},"engines":{"streams":{"instance_id":1592952663691,"userPythonPackages":["scikit-learn==0.21.3","joblib","mnist"]}},"deploy":{}}}